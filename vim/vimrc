set nocompatible
" clear previous variable settings
filetype on
filetype plugin indent on
syntax on

if empty(glob("~/.vim/autoload/plug.vim"))
    " Download the actual plugin manager
    silent execute '!mkdir -p ~/.vim/autoload/'
    silent execute '!wget -P ~/.vim/autoload https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
endif


if !has("compatible")
   call plug#begin('~/.vim/plugged')
   " Appearance
   Plug 'altercation/vim-colors-solarized'

   "usability
   Plug 'Konfekt/FastFold'
   Plug 'christoomey/vim-tmux-navigator'
   Plug 'tpope/vim-fugitive'
   Plug 'tpope/vim-unimpaired'
   Plug 'tpope/vim-dispatch'
   Plug 'tpope/vim-surround'
   Plug 'tpope/vim-repeat'
   Plug 'tpope/vim-sensible'
   Plug 'tpope/vim-commentary'
   Plug 'moll/vim-bbye'

   "Languages
   Plug 'vim-scripts/gnuplot.vim'
   Plug 'vim-scripts/indentpython.vim'

   "Tools
   Plug 'MarcWeber/vim-addon-mw-utils'
   Plug 'tomtom/tlib_vim'
   Plug 'garbas/vim-snipmate'
   Plug 'scrooloose/syntastic', {'on': ['SyntasticCheck', 'SyntasticInfo']}
   Plug 'vim-scripts/LanguageTool'
   Plug 'junegunn/vim-easy-align'

   " Own plugins
   Plug 'thepith/vim-snippets'
   Plug 'thepith/VimPascalHelp'

   call plug#end()
endif
let mapleader="\<Space>"

" Plugins
" solarized
set t_Co=256 " use 256 colors
set background=light
let solenv=$SOLVAR
if solenv == "light"
   set background=light
endif
if solenv == "dark"
   set background=dark
endif
silent! colorscheme solarized

" Dispatch
" Inspect runner pane
map <F5> :update<CR>:Dispatch ./% <CR>
" Run last command executed by VimuxRunCommand
map <F6> :update<CR>:Dispatch<CR>
"" Prompt for a command to run
map <F7> :update<CR>:FocusDispatch
"" run make
let target = ""
map <F8> :let target = ""<left>
"" run make
map <F9> :update<CR>:exe 'Make '.target<Cr>

" Syntastic
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0 " Don't auto open/close location list
let g:syntastic_check_on_open = 0 "Never run syntastic automatically
let g:syntastic_check_on_wq = 0 "Never run syntastic automatically
let g:syntastic_mode_map={"mode" : "passive"}
let g:syntastic_enable_signs=1
let g:syntastic_quiet_messages = {
         \ "regex": "\\max"}
if executable("ifort")
   let g:syntastic_fortran_compiler = "ifort"
   let g:syntastic_fortran_compiler_options = "-no-save-temps
            \ -y -warn -nogen-interfaces"
else
   let g:syntastic_fortran_compiler = "gfortran"
   let g:syntastic_fortran_compiler_options = "-Wall -O0"
endif
let g:syntastic_tex_chktex_nowarn=24
"command to run syntastic
nnoremap <leader>sc :update<CR>:SyntasticCheck<CR>

" commentary
map <leader>cc :Commentary<CR>

" vim-bbye
nnoremap <Leader>q :Bdelete<CR>

" LanguageTool
let g:languagetool_jar='$HOME/.languagetools/languagetool-commandline.jar'
nnoremap <leader>gm :update<CR>:LanguageToolCheck<CR>
nnoremap <leader>gc :LanguageToolClear

" snippets
let g:snipMate = {}
let g:snipMate.snippet_version = 1
"surround
let g:surround_{char2nr('c')} = "\\\1command\1{\r}"
"fortran.vim
let fortran_free_source=1
let fortran_do_enddo=1
let fortran_have_tabs=1
"gnuplot
au BufRead,BufNewFile *.gpl,*.gpi set filetype=gnuplot
"fast fold
if !has("compatible")
   set nofoldenable
endif
let fortran_fold=1
let g:cpp_fold_enabled=1
let g:fortran_fold_enabled=1
let g:fastfold_fold_command_suffixes = []
let g:fastfold_fold_movement_commands = []
let g:fastfold_savehook = 0

"easy-align
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap <leader>a <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap <leader>a <Plug>(EasyAlign)

" Start to regex
xmap <leader>t :EasyAlign //<left>


let g:easy_align_delimiters = {
         \  '!': { 'pattern': '!\+', 'delimiter_align': 'l',
         \         'ignore_groups': ['!Comment']  },
         \ }

"
"Own functions
if !has("compatible")
   set nf=octal,hex,alpha
   function! Incr()
      let a = line('.') - line("'<")
      let c = virtcol("'<")
      if a > 0
         execute 'normal! '.c.'|'.a."\<C-a>"
      endif
      normal `<
   endfunction
   function! DoFold()
      echom "fold"
      if &foldenable
         set nofoldenable
      else
         set foldenable
         let &foldmethod=b:wantedfoldmethod
         echo b:wantedfoldmethod
         set foldlevel=0
         set foldnestmax=2
      endif
   endfunction
   function! GenerateCtags()
      let ctagdir = substitute(system('git rev-parse --git-dir 2> /dev/null || echo -n "."'), '[[:cntrl:]]', '', 'g')
      let ctagwdir = substitute(system('git rev-parse --show-toplevel 2> /dev/null || echo -n "."'), '[[:cntrl:]]', '', 'g')
      echom ctagwdir
      echom ctagdir
      execute '!ctags -R --tag-relative=yes -f"'.ctagdir.'/tags" '.ctagwdir
      e!
   endfunction
   command! MakeCtags :call GenerateCtags()
endif

" General Settings
set encoding=utf-8
set spelllang=en_us
set hidden
set path+=** "fuzzy search
set wildmode=longest:full,full
set wildmenu " Better command-line completion
set showcmd " Show partial commands in the last line of the screen
set hlsearch " Highlight searches
set ignorecase " Use case insensitive search
set smartcase " When using capital letters do not use ignorecase
set backspace=indent,eol,start " Allow backspacing over autoindent, line breaks and start of insert action
set smartindent " When opening a new line and no filetype-specific indenting is enabled, keep the same indent as the line you're currently on. Useful for READMEs, etc.
if exists('+breakindent')
   set breakindent "indent wrapped lines
endif
set nostartofline " Stop certain movements from always going to the first character of a line.
set ruler " Display the cursor position on the last line of the screen or in the status line of a window
" Status Line {
set laststatus=2                             " always show statusbar
set statusline=
set statusline+=\<%n\>\                     " buffer number
set statusline+=%f\                          " filename
set statusline+=%h%m%r%w                     " status flags
set statusline+=\[%{strlen(&ft)?&ft:'none'}] " file type
set statusline+=%=                           " right align remainder
set statusline+=%-14(%l,%c%V%)               " line, character
"}
set confirm " Instead of failing a command because of unsaved changes, instead raise a dialogue asking if you wish to save changed files.
set visualbell " Use visual bell instead of beeping when doing something wrong
set t_vb= " And reset the terminal code for the visual bell. If visualbell is set, and this line is also included, vim will neither flash nor beep. If visualbell is unset, this does nothing.
set cmdheight=2 " Set the command window height to 2 lines, to avoid many cases of having to press <CR> to continue
set number " Display line numbers on the left
set notimeout ttimeout ttimeoutlen=200 " Quickly time out on keycodes, but never time out on mappings
"todo: are these needed?
"set formatoptions-=t
"set formatoptions-=c
"autocmd BufNewFile,BufRead * setlocal formatoptions-=tc
"
set wrap "wrap lines at breakat
"show line with break
set showbreak=··\ 
set nolist  " list disables linebreak
"color break as the linenumbers
hi NonText ctermbg=7
"show ExtraWhitespace as light red
highlight ExtraWhitespace ctermbg=223
"Highlight ExtraWhitespace
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()
" Indentation settings for using 3 spaces instead of tabs.
set shiftwidth=3
set softtabstop=3
set expandtab
"Show bad spelling as underlined
hi clear SpellBad
hi SpellBad cterm=underline
"use system clipboad
set clipboard=unnamed
" easy split
set splitbelow
set splitright
" Switch between block and vertical cursor
let &t_ti.="\e[1 q"
let &t_SI.="\e[5 q"
let &t_EI.="\e[1 q"
let &t_te.="\e[0 q"
" show textwidth
set colorcolumn=+1

" use vim Menu
source $VIMRUNTIME/menu.vim
set cpo-=<
set wcm=<C-Z>

" Map Keys
nmap <F4> :emenu <C-Z>
set pastetoggle=<F4> " Use <F4> to toggle between 'paste' and 'nopaste'
" Map Y to act like D and C, i.e. to yank until EOL, rather than act as yy,
" which is the default
map Y y$
" turn of highlight until the next search
nmap <leader>nn :nohl<CR>
" use to naviage buffers easily
nnoremap <leader>b :ls<CR>:b<Space>
" enter works in normal mode
nmap <CR> o<Esc>k
if !has("compatible")
   vnoremap <C-a> :call Incr()<CR>
endif
" do not use arrow keys!
noremap <Up>    :echo "Stop using arrow keys, stupid" <CR>
noremap <Down>  :echo "Stop using arrow keys, stupid" <CR>
noremap <Left>  :echo "Stop using arrow keys, stupid" <CR>
noremap <Right> :echo "Stop using arrow keys, stupid" <CR>
inoremap <Up>    <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Down>  <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Left>  <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Right> <Esc>:echo "Stop using arrow keys, stupid" <CR> i
" custom copy'n'paste
vmap <leader>y :w! /tmp/$USER/.vim/vbuf<CR>
nmap <leader>y :.w! /tmp/$USER/.vim/vbuf<CR>
nmap <leader>p :r /tmp/$USER/.vim/vbuf<CR>
" navigate tabs
nmap <leader>h :tabprevious<CR>
nmap <leader>l :tabnext<CR>
nmap <leader>H :tabm -1<CR>
nmap <leader>L :tabm +1<CR>
" navigate buffers
nmap <leader>k :bprevious<CR>
nmap <leader>j :bnext<CR>
" change current dir of the window
nnoremap <leader>cd :lcd %:p:h<CR>:pwd<CR>
" fold
command! Fold :call DoFold()
noremap <leader>fo :Fold<CR>
noremap <leader>ff :find<Space>
"legacy
" move to tag
nmap <leader>fs <C-]>
" unmap ex mode
nnoremap Q <nop>

"File type specific settings
"Markdown
autocmd BufNewFile,BufFilePre,BufRead *.md setlocal filetype=markdown
au FileType markdown setlocal spell
"Fortran
au FileType fortran let b:wantedfoldmethod="syntax"
au FileType fortran setlocal textwidth=132
"python
au Filetype python
         \ setlocal tabstop=4 |
         \ setlocal softtabstop=4 |
         \ setlocal shiftwidth=4 |
         \ setlocal textwidth=79 |
         \ setlocal expandtab |
         \ setlocal autoindent |
         \ setlocal fileformat=unix

let python_highlight_all=1
au FileType python let b:wantedfoldmethod="indent"
" cpp
au FileType cpp let b:wantedfoldmethod="syntax"
au FileType cpp setlocal textwidth=80
au FileType cpp setlocal shiftwidth=2 " Indentation settings for using 2 spaces instead of tabs.
au FileType cpp setlocal softtabstop=2 " Indentation settings for using 2 spaces instead of tabs.
au FileType cpp setlocal expandtab
" gnuplot
au FileType gnuplot setlocal commentstring =#\ %s*


" Initialize Directories

if has('persistent_undo')      "check if your vim version supports it
   function! InitializeDirectories()
      let separator = "."
      let parent = "/tmp/".$USER.""
      let prefix = '.vim/'
      let dir_list = { 'undo/': 'undodir'}

      for [dirname, settingname] in items(dir_list)
         let directory = parent . '/' . prefix . dirname . "/"
         if exists("\*mkdir")
            if !isdirectory(directory)
               call mkdir(directory, "p")
            endif
         endif
         if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " .
            directory
            echo "Try: mkdir -p " . directory
         else
            let directory = substitute(directory, " ", "\\\\\\\\ ", "")
            exec "set " . settingname . "=" . directory
         endif
      endfor
   endfunction
   call InitializeDirectories()
   set undofile
endif
