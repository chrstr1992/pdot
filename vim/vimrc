" clear previous variable settings
filetype on
filetype plugin indent on
syntax on

if empty(glob("~/.vim/autoload/plug.vim"))
    " Download the actual plugin manager
    silent execute '!mkdir -p ~/.vim/autoload/'
    silent execute '!wget -P ~/.vim/autoload https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
endif


if !has("compatible")
   call plug#begin('~/.vim/plugged')
   " Appearance
   Plug 'altercation/vim-colors-solarized'

   "usability
   Plug 'christoomey/vim-tmux-navigator'
   Plug 'tpope/vim-fugitive'
   Plug 'tpope/vim-unimpaired'
   Plug 'tpope/vim-dispatch'
   Plug 'tpope/vim-surround'
   Plug 'tpope/vim-repeat'
   Plug 'tpope/vim-sensible'
   Plug 'tpope/vim-commentary'
   Plug 'moll/vim-bbye'

   "Languages
   Plug 'vim-scripts/gnuplot.vim'
   Plug 'vim-scripts/indentpython.vim'

   "Tools
   Plug 'MarcWeber/vim-addon-mw-utils'
   Plug 'tomtom/tlib_vim'
   Plug 'garbas/vim-snipmate'
   Plug 'scrooloose/syntastic', {'on': ['SyntasticCheck', 'SyntasticInfo']}
   Plug 'vim-scripts/LanguageTool'
   Plug 'junegunn/vim-easy-align'

   " Own plugins
   Plug 'thepith/vim-snippets'

   "Undo
   Plug 'sjl/gundo.vim', {'on': ['GundoToggle']}

   call plug#end()
endif
let mapleader="\<Space>"

" Plugins
" solarized
set background=light
let g:solarized_visibility="high"
let solenv=$SOLVAR
if solenv == "light"
   set background=light
endif
if solenv == "dark"
   set background=dark
endif
silent! colorscheme solarized

" Dispatch
" Inspect runner pane
nnoremap <F5> :update<CR>:Dispatch ./% <CR>
" Run last command executed by VimuxRunCommand
nnoremap <F6> :update<CR>:Dispatch<CR>
"" Prompt for a command to run
nnoremap <F7> :update<CR>:FocusDispatch
"" run make
let target = ""
nnoremap <F8> :let target = ""<left>
"" run make
nnoremap <F9> :update<CR>:exe 'Make '.target<Cr>

" Syntastic
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0 " Don't auto open/close location list
let g:syntastic_check_on_open = 0 " Never run syntastic automatically
let g:syntastic_check_on_wq = 0   " Never run syntastic automatically
let g:syntastic_mode_map={"mode" : "passive"}
let g:syntastic_enable_signs=1
let g:syntastic_quiet_messages = {
         \ "regex": "\\max"}
if executable("ifort")
   let g:syntastic_fortran_compiler = "ifort"
   let g:syntastic_fortran_compiler_options = "-no-save-temps
            \ -y -warn -nogen-interfaces"
else
   let g:syntastic_fortran_compiler = "gfortran"
   let g:syntastic_fortran_compiler_options = "-Wall -O0"
endif
"command to run syntastic
nnoremap <leader>sc :update<CR>:SyntasticCheck<CR>

" commentary
map <leader>cc :Commentary<CR>

" vim-bbye
nnoremap <Leader>q :Bdelete<CR>

" LanguageTool
let g:languagetool_jar='$HOME/.languagetools/languagetool-commandline.jar'
nnoremap <leader>gm :update<CR>:LanguageToolCheck<CR>
nnoremap <leader>gc :LanguageToolClear

" snippets
let g:snipMate = {}
let g:snipMate.snippet_version = 1

"surround
let g:surround_{char2nr('c')} = "\\\1command\1{\r}"

"fortran.vim
let fortran_free_source=1
let fortran_do_enddo=1
let fortran_have_tabs=1

"fast fold
if !has("compatible")
   set nofoldenable
endif
set foldmethod=manual
set foldlevel=0
set foldnestmax=2
let fortran_fold=1
" let g:cpp_fold_enabled=1
" let g:fortran_fold_enabled=1
" let g:fastfold_fold_command_suffixes = []
" let g:fastfold_fold_movement_commands = []
" let g:fastfold_savehook = 0
nnoremap <leader>fo :let &foldmethod=b:wantedfoldmethod<CR>

"easy-align
" Start interactive EasyAlign in visual mode (e.g. vipga)
xnoremap <leader>a <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nnoremap <leader>a <Plug>(EasyAlign)
" Start to regex
xnoremap <leader>t :EasyAlign //<left>
let g:easy_align_delimiters = {
         \  '!': { 'pattern': '!\+', 'delimiter_align': 'l',
         \         'ignore_groups': ['!Comment']  },
         \ }

"Gundo.vim
nnoremap <leader>u :GundoToggle<CR>


"
"Own functions
if !has("compatible")
   set nrformats=octal,hex,alpha
   function! Incr()
      let a = line('.') - line("'<")
      let c = virtcol("'<")
      if a > 0
         execute 'normal! '.c.'|'.a."\<C-a>"
      endif
      normal `<
   endfunction
   vnoremap <C-a> :call Incr()<CR>
   function! GenerateCtags()
      let ctagdir = substitute(system('git rev-parse --git-dir 2> /dev/null || echo -n "."'), '[[:cntrl:]]', '', 'g')
      let ctagwdir = substitute(system('git rev-parse --show-toplevel 2> /dev/null || echo -n "."'), '[[:cntrl:]]', '', 'g')
      echom ctagwdir
      echom ctagdir
      execute '!ctags -R --tag-relative=yes -f"'.ctagdir.'/tags" '.ctagwdir
      e!
   endfunction
   command! MakeCtags :call GenerateCtags()
endif

" General Settings
set encoding=utf-8
set spelllang=en_us
set hidden
set path+=** "fuzzy search
set wildmode=longest:full,full
set wildmenu " Better command-line completion
set showcmd " Show partial commands in the last line of the screen
set hlsearch " Highlight searches
set ignorecase " Use case insensitive search
set smartcase " When using capital letters do not use ignorecase
set backspace=indent,eol,start " Allow backspacing over autoindent, line breaks and start of insert action
set smartindent " When opening a new line and no filetype-specific indenting is enabled, keep the same indent as the line you're currently on. Useful for READMEs, etc.
if exists('+breakindent')
   set breakindent "indent wrapped lines
endif
set nostartofline " Stop certain movements from always going to the first character of a line.
set ruler " Display the cursor position on the last line of the screen or in the status line of a window

" Status Line {
set laststatus=2                             " always show statusbar
set statusline=
set statusline+=\<%n\>\                     " buffer number
set statusline+=%f\                          " filename
set statusline+=%h%m%r%w                     " status flags
set statusline+=\[%{strlen(&ft)?&ft:'none'}] " file type
set statusline+=%=                           " right align remainder
set statusline+=%5(%l%),%-9(%c%V%)\          " line, character

" now set it up to change the status line based on mode
if version >= 700
   highlight StatusLine ctermfg=6 ctermbg=0
   autocmd InsertEnter * highlight StatusLine ctermfg=3 ctermbg=0
   autocmd InsertLeave * highlight StatusLine ctermfg=6 ctermbg=0
endif
"}

set confirm " Instead of failing a command because of unsaved changes, instead raise a dialogue asking if you wish to save changed files.
set visualbell " Use visual bell instead of beeping when doing something wrong
set t_vb= " And reset the terminal code for the visual bell. If visualbell is set, and this line is also included, vim will neither flash nor beep. If visualbell is unset, this does nothing.
set cmdheight=2 " Set the command window height to 2 lines, to avoid many cases of having to press <CR> to continue
set number " Display line numbers on the left
set notimeout ttimeout ttimeoutlen=200 " Quickly time out on keycodes, but never time out on mappings
set wrap "wrap lines at breakat
"show line with break
let &showbreak = 'â–º'
set nolist  " list disables linebreak
"show ExtraWhitespace as light red
highlight ExtraWhitespace ctermbg=9
"Highlight ExtraWhitespace
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()
" Indentation settings for using 3 spaces instead of tabs.
set shiftwidth=3
set softtabstop=3
set expandtab
"Show bad spelling as underlined
highlight clear SpellBad
highlight SpellBad cterm=underline
"use system clipboad
set clipboard=unnamed
" easy split
set splitbelow
set splitright
" show textwidth
set colorcolumn=+1

set pastetoggle=<F4> " Use <F4> to toggle between 'paste' and 'nopaste'
" Map Y to act like D and C, i.e. to yank until EOL, rather than act as yy,
" which is the default
map Y y$
" turn of highlight until the next search
nnoremap <leader>nn :nohlsearch<CR>
" use to naviage buffers easily
nnoremap <leader>b :buffers<CR>:buffer<Space>
" use to naviage buffers easily
nnoremap <leader>o :buffer#<CR>
" enter works in normal mode
nnoremap <CR> o<Esc>k
" do not use arrow keys!
noremap <Up>    :echo "Stop using arrow keys, stupid" <CR>
noremap <Down>  :echo "Stop using arrow keys, stupid" <CR>
noremap <Left>  :echo "Stop using arrow keys, stupid" <CR>
noremap <Right> :echo "Stop using arrow keys, stupid" <CR>
inoremap <Up>    <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Down>  <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Left>  <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Right> <Esc>:echo "Stop using arrow keys, stupid" <CR> i
" custom copy'n'paste
vnoremap <leader>y :w! /tmp/$USER/.vim/vbuf<CR>
nnoremap <leader>y :.w! /tmp/$USER/.vim/vbuf<CR>
nnoremap <leader>p :r /tmp/$USER/.vim/vbuf<CR>
" navigate tabs
nnoremap <leader>h :tabprevious<CR>
nnoremap <leader>l :tabnext<CR>
nnoremap <leader>H :tabm -1<CR>
nnoremap <leader>L :tabm +1<CR>
" navigate buffers
nnoremap <leader>k :bprevious<CR>
nnoremap <leader>j :bnext<CR>
" change current dir of the window
nnoremap <leader>cd :lcd %:p:h<CR>:pwd<CR>
" fold
noremap <leader>ff :find<Space>
"legacy
" unmap ex mode
nnoremap Q <nop>
" Quickly open/reload vim
nnoremap <leader>ev :vsplit $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>

"File type specific settings
"Markdown
autocmd BufNewFile,BufFilePre,BufRead *.md setlocal filetype=markdown
autocmd FileType markdown setlocal spell
"Fortran
autocmd FileType fortran let b:wantedfoldmethod="syntax"
autocmd FileType fortran setlocal textwidth=132
"python
autocmd Filetype python
         \ setlocal tabstop=4 |
         \ setlocal softtabstop=4 |
         \ setlocal shiftwidth=4 |
         \ setlocal textwidth=79 |
         \ setlocal expandtab |
         \ setlocal autoindent |
         \ setlocal fileformat=unix

let python_highlight_all=1
autocmd FileType python let b:wantedfoldmethod="indent"
" cpp
autocmd FileType cpp let b:wantedfoldmethod="syntax"
autocmd FileType cpp setlocal textwidth=80
autocmd FileType cpp setlocal shiftwidth=2 " Indentation settings for using 2 spaces instead of tabs.
autocmd FileType cpp setlocal softtabstop=2 " Indentation settings for using 2 spaces instead of tabs.
autocmd FileType cpp setlocal expandtab
" gnuplot
autocmd BufRead,BufNewFile *.gpl,*.gpi,*.plt set filetype=gnuplot
autocmd FileType gnuplot setlocal commentstring =#\ %s


" Initialize Directories
if has('persistent_undo')      "check if your vim version supports it
   function! InitializeDirectories()
      let parent = "/tmp/".$USER.""
      let prefix = '.vim/'
      let dir_list = { 'undo/': 'undodir'}

      for [dirname, settingname] in items(dir_list)
         let directory = parent . '/' . prefix . dirname . "/"
         if exists("\*mkdir")
            if !isdirectory(directory)
               call mkdir(directory, "p")
            endif
         endif
         if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " . directory
            echo "Try: mkdir -p " . directory
         else
            let directory = substitute(directory, " ", "\\\\\\\\ ", "")
            exec "set " . settingname . "=" . directory
         endif
      endfor
   endfunction
   call InitializeDirectories()
   set undofile
endif
