set encoding=utf-8
scriptencoding utf-8
" clear previous variable settings
filetype on
filetype plugin indent on
syntax on

if empty(glob('~/.vim/autoload/plug.vim'))
    " Download the actual plugin manager
    silent execute '!mkdir -p ~/.vim/autoload/'
    silent execute '!wget -P ~/.vim/autoload https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
endif


if !has('compatible')
   call plug#begin('~/.vim/plugged')
   " Appearance
   Plug 'altercation/vim-colors-solarized'

   "usability
   Plug 'christoomey/vim-tmux-navigator'
   Plug 'tpope/vim-fugitive'
   Plug 'tpope/vim-unimpaired'
   Plug 'tpope/vim-dispatch'
   Plug 'tpope/vim-surround'
   Plug 'tpope/vim-repeat'
   Plug 'tpope/vim-sensible'
   Plug 'tpope/vim-commentary'
   Plug 'moll/vim-bbye'

   "Languages
   Plug 'vim-scripts/gnuplot.vim'
   Plug 'vim-scripts/indentpython.vim'

   "Tools
   Plug 'MarcWeber/vim-addon-mw-utils'
   Plug 'tomtom/tlib_vim'
   Plug 'garbas/vim-snipmate'
   if v:version >= 800
      Plug 'w0rp/ale', {'on': ['ALELint', 'ALEInfo', 'ALEToggle']}
   else
      Plug 'scrooloose/syntastic', {'on': ['SyntasticCheck', 'SyntasticInfo']}
   endif
   Plug 'vim-scripts/LanguageTool'
   Plug 'junegunn/vim-easy-align'

   " Own plugins
   Plug 'thepith/vim-snippets'

   "Undo
   Plug 'sjl/gundo.vim', {'on': ['GundoToggle']}

   call plug#end()
endif
let g:mapleader="\<Space>"

" Plugins
" solarized
set background=light
let g:solarized_visibility='high'
let g:solenv=$SOLVAR
if g:solenv ==? 'light'
   set background=light
endif
if g:solenv ==? 'dark'
   set background=dark
endif
silent! colorscheme solarized

" Dispatch
" Inspect runner pane
nnoremap <F5> :update<CR>:Dispatch ./% <CR>
" Run last command executed by VimuxRunCommand
nnoremap <F6> :update<CR>:Dispatch<CR>
"" Prompt for a command to run
nnoremap <F7> :update<CR>:FocusDispatch
"" run make
let g:target = ''
nnoremap <F8> :let g:target = ""<left>
"" run make
nnoremap <F9> :update<CR>:exe 'Make '.target<Cr>


if v:version >= 800
   " ale
   " let g:ale_lint_on_text_changed='never'
   " let g:ale_lint_on_insert_leave=0
   " let g:ale_lint_on_enter=0
   " let g:ale_lint_on_save=0
   let g:airline#extensions#ale#enabled=0
   let g:ale_linters = {'fortran': ['gfortran']}
   let g:ale_enabled = 0
   nnoremap <leader>sc :update<CR>:ALEToggle<CR>
else
   " Syntastic
   let g:syntastic_always_populate_loc_list = 1
   let g:syntastic_auto_loc_list = 0 " Don't auto open/close location list
   let g:syntastic_check_on_open = 0 " Never run syntastic automatically
   let g:syntastic_check_on_wq = 0   " Never run syntastic automatically
   let g:syntastic_mode_map={'mode' : 'Passive'}
   let g:syntastic_enable_signs=1
   let g:syntastic_quiet_messages = { 'regex': '\max'}
   let g:syntastic_vim_checkers = ['vint']
   if executable('ifort')
      let g:syntastic_fortran_compiler = 'ifort'
      let g:syntastic_fortran_compiler_options = '-no-save-temps
               \ -y -warn -nogen-interfaces'
   else
      let g:syntastic_fortran_compiler = 'gfortran'
      let g:syntastic_fortran_compiler_options = '-Wall -O0'
   endif
   "command to run syntastic
   nnoremap <leader>sc :update<CR>:SyntasticCheck<CR>
endif

" commentary
map <leader>cc :Commentary<CR>

" vim-bbye
nnoremap <Leader>q :Bdelete<CR>

" LanguageTool
let g:languagetool_jar='$HOME/.languagetools/languagetool-commandline.jar'
nnoremap <leader>gm :update<CR>:LanguageToolCheck<CR>
nnoremap <leader>gc :LanguageToolClear

" snippets
let g:snipMate = {}
let g:snipMate.snippet_version = 1

"surround
let g:surround_{char2nr('c')} = "\\\1command\1{\r}"

"easy-align
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap <leader>a <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap <leader>a <Plug>(EasyAlign)
" Start to regex
xnoremap <leader>t :EasyAlign //<left>
let g:easy_align_delimiters = {
         \  '!': { 'pattern': '!\+', 'delimiter_align': 'l',
         \         'ignore_groups': ['!Comment']  },
         \ }

"Gundo.vim
nnoremap <leader>u :GundoToggle<CR>


"
"Own functions
if !has('compatible')
   set nrformats=octal,hex,alpha
   function! Incr()
      let l:a = line('.') - line("'<")
      let l:c = virtcol("'<")
      if l:a > 0
         execute 'normal! '.l:c.'|'.l:a."\<C-a>"
      endif
      normal! `<
   endfunction
   vnoremap <C-a> :call Incr()<CR>
   function! GenerateCtags()
      let l:ctagdir = substitute(system('git rev-parse --git-dir 2> /dev/null || echo -n "."'), '[[:cntrl:]]', '', 'g')
      let l:ctagwdir = substitute(system('git rev-parse --show-toplevel 2> /dev/null || echo -n "."'), '[[:cntrl:]]', '', 'g')
      echom l:ctagwdir
      echom l:ctagdir
      execute '!ctags -R --tag-relative=yes -f"'.l:ctagdir.'/tags" '.l:ctagwdir
      e!
   endfunction
   command! MakeCtags :call GenerateCtags()
endif

" General Settings
set spelllang=en_us
set hidden
set path+=** "fuzzy search
set wildmode=longest:full,full
set wildmenu " Better command-line completion
set showcmd " Show partial commands in the last line of the screen
set hlsearch " Highlight searches
set ignorecase " Use case insensitive search
set smartcase " When using capital letters do not use ignorecase
set backspace=indent,eol,start " Allow backspacing over autoindent, line breaks and start of insert action
set smartindent " When opening a new line and no filetype-specific indenting is enabled, keep the same indent as the line you're currently on. Useful for READMEs, etc.
if exists('+breakindent')
   set breakindent "indent wrapped lines
endif
set nostartofline " Stop certain movements from always going to the first character of a line.
set ruler " Display the cursor position on the last line of the screen or in the status line of a window

" Status Line {
set laststatus=2                             " always show statusbar
set statusline=
set statusline+=\<%n\>\                     " buffer number
set statusline+=%f\                          " filename
set statusline+=%h%m%r%w                     " status flags
set statusline+=\[%{strlen(&ft)?&ft:'none'}] " file type
set statusline+=%=                           " right align remainder
set statusline+=%5(%l%),%-9(%c%V%)\          " line, character

" now set it up to change the status line based on mode
if v:version >= 700
   highlight StatusLine ctermfg=6 ctermbg=0
   augroup statusHighlight
      autocmd InsertEnter * highlight StatusLine ctermfg=3 ctermbg=0
      autocmd InsertLeave * highlight StatusLine ctermfg=6 ctermbg=0
   augroup END
endif
"}

set confirm " Instead of failing a command because of unsaved changes, instead raise a dialogue asking if you wish to save changed files.
set visualbell " Use visual bell instead of beeping when doing something wrong
set t_vb= " And reset the terminal code for the visual bell. If visualbell is set, and this line is also included, vim will neither flash nor beep. If visualbell is unset, this does nothing.
set cmdheight=2 " Set the command window height to 2 lines, to avoid many cases of having to press <CR> to continue
set notimeout ttimeout ttimeoutlen=200 " Quickly time out on keycodes, but never time out on mappings
set wrap "wrap lines at breakat
"show line with break
let &showbreak = ' â–º'
set nolist  " list disables linebreak
"show ExtraWhitespace as light red
highlight ExtraWhitespace ctermbg=9
"Highlight ExtraWhitespace
match ExtraWhitespace /\s\+$/
augroup extraWhitespaceHighlight
   autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
   autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
   autocmd InsertLeave * match ExtraWhitespace /\s\+$/
   autocmd BufWinLeave * call clearmatches()
augroup end
" Indentation settings for using 3 spaces instead of tabs.
set shiftwidth=3
set softtabstop=3
set expandtab
"Show bad spelling as underlined
highlight clear SpellBad
highlight SpellBad cterm=underline
"use system clipboad
set clipboard=unnamed
" easy split
set splitbelow
set splitright
" show textwidth
set colorcolumn=+1

"mappings
set pastetoggle=<F4> " Use <F4> to toggle between 'paste' and 'nopaste'
" Map Y to act like D and C, i.e. to yank until EOL, rather than act as yy,
" which is the default
map Y y$
" turn of highlight until the next search
nnoremap <leader>nn :nohlsearch<CR>
" use to naviage buffers easily
nnoremap <leader>b :buffers<CR>:buffer<Space>
" use to naviage buffers easily
nnoremap <leader>o :buffer#<CR>
" use to naviage buffers easily
nnoremap <leader>cb :filter /^[^\/]*$/ buffers<CR>:buffer<Space>
" do not use arrow keys!
noremap <Up>    :echo "Stop using arrow keys, stupid" <CR>
noremap <Down>  :echo "Stop using arrow keys, stupid" <CR>
noremap <Left>  :echo "Stop using arrow keys, stupid" <CR>
noremap <Right> :echo "Stop using arrow keys, stupid" <CR>
inoremap <Up>    <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Down>  <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Left>  <Esc>:echo "Stop using arrow keys, stupid" <CR> i
inoremap <Right> <Esc>:echo "Stop using arrow keys, stupid" <CR> i
" custom copy'n'paste
vnoremap <leader>y :w! /tmp/$USER/.vim/vbuf<CR>
nnoremap <leader>y :.w! /tmp/$USER/.vim/vbuf<CR>
nnoremap <leader>p :r /tmp/$USER/.vim/vbuf<CR>
" navigate tabs
nnoremap <leader>h :tabprevious<CR>
nnoremap <leader>l :tabnext<CR>
nnoremap <leader>H :tabm -1<CR>
nnoremap <leader>L :tabm +1<CR>
" navigate buffers
nnoremap <leader>k :bprevious<CR>
nnoremap <leader>j :bnext<CR>
" change current dir of the window
nnoremap <leader>cd :lcd %:p:h<CR>:pwd<CR>
" unmap ex mode
nnoremap Q <nop>
" Quickly open/reload vim
nnoremap <leader>ev :vsplit $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>

"folding
if !has('compatible')
   set nofoldenable
   set foldmethod=manual
   set foldlevel=0
   set foldnestmax=2
   let g:fortran_fold=1
   nnoremap <leader>fo :let &foldmethod=b:wantedfoldmethod<CR>
endif

"File type specific settings
"Markdown
autocmd BufNewFile,BufFilePre,BufRead *.md setlocal filetype=markdown
autocmd FileType markdown setlocal spell
"Fortran
let g:fortran_free_source=1
let g:fortran_do_enddo=1
let g:fortran_have_tabs=1
autocmd FileType fortran let b:wantedfoldmethod="syntax"
autocmd FileType fortran setlocal textwidth=132
"python
autocmd Filetype python
         \ setlocal tabstop=4 |
         \ setlocal softtabstop=4 |
         \ setlocal shiftwidth=4 |
         \ setlocal textwidth=79 |
         \ setlocal expandtab |
         \ setlocal autoindent |
         \ setlocal fileformat=unix

let g:python_highlight_all=1
autocmd FileType python let b:wantedfoldmethod="indent"
" cpp
autocmd FileType cpp let b:wantedfoldmethod="syntax"
autocmd FileType cpp setlocal textwidth=80
autocmd FileType cpp setlocal shiftwidth=2 " Indentation settings for using 2 spaces instead of tabs.
autocmd FileType cpp setlocal softtabstop=2 " Indentation settings for using 2 spaces instead of tabs.
autocmd FileType cpp setlocal expandtab
" gnuplot
autocmd BufRead,BufNewFile *.gpl,*.gpi,*.plt set filetype=gnuplot
autocmd FileType gnuplot setlocal commentstring =#\ %s

" Initialize Directories
if has('persistent_undo')      "check if your vim version supports it
   function! InitializeDirectories()
      let l:parent = '/tmp/'.$USER.''
      let l:prefix = '.vim/'
      let l:dir_list = { 'undo/': 'undodir'}

      for [l:dirname, l:settingname] in items(l:dir_list)
         let l:directory = l:parent . '/' . l:prefix . l:dirname . '/'
         if exists('\*mkdir')
            if !isdirectory(l:directory)
               call mkdir(l:directory, 'p')
            endif
         endif
         if !isdirectory(l:directory)
            echo 'Warning: Unable to create backup directory: ' . l:directory
            echo 'Try: mkdir -p ' . l:directory
         else
            let l:directory = substitute(l:directory, ' ', '\\ ', '')
            exec 'set ' . l:settingname . '=' . l:directory
         endif
      endfor
   endfunction
   call InitializeDirectories()
   set undofile
endif
